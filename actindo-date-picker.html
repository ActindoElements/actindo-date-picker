<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../paper-dialog/paper-dialog.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../paper-date-picker/paper-date-picker.html">
<link rel="import" href="../iron-icon/iron-icon.html">
<link rel="import" href="../polymer/lib/utils/debounce.html">

<!--
`<actindo-date-picker>` implements a material design based date picker.

### Features

- format can be set based on style and location
- date is automatically validated during input
- date and year can be selected
- minimum and maximum date can be set

-->

<dom-module id="actindo-date-picker">

    <template>

        <style>

            .container {
                position: relative;
                background-color: white;
            }

            #dialog {
                z-index: 1;
                position: absolute;
                background-color: white;
            }

            paper-date-picker {
                --light-primary-color: rgba(255, 255, 255, 0.5);
                --text-primary-color: rgba(255, 255, 255, 1);
                --default-primary-color: var(--actindo-primary);
                --paper-font-body1_-_font-weight: 500;
                --primary-text-color: rgba(33, 33, 33, 0.7);
                --secondary-text-color: rgba(33, 33, 33, 0.5);
            }

            paper-icon-button {
                position: absolute;
                top: -11px;
                right: 0px;
            }

            ::-webkit-scrollbar {
                width: 10px;
                height: 10px;
                padding-right: 5px;
            }

            ::-webkit-scrollbar-track {
                background: transparent;
            }

            ::-webkit-scrollbar-track:hover {
                background: rgba(0, 0, 0, 0.15);
            }

            ::-webkit-scrollbar-thumb {
                background-color: var(--actindo-secondary-light);
                border-right: 2px solid var(--actindo-secondary-light);
                border-left: 2px solid var(--actindo-secondary-light);
            }

            ::-webkit-scrollbar-thumb:hover {
                background-color: var(--actindo-secondary);
                border-right: 2px solid var(--actindo-secondary);
                border-left: 2px solid var(--actindo-secondary);
            }

        </style>

        <div class="container">
            <paper-input label="[[label]]" value="{{value}}" type="[[_dateInputType]]" invalid="[[invalid]]"
                         error-message="[[_errorMessage]]" required="[[required]]" disabled="[[disabled]]">
                <paper-icon-button icon="date-range" slot="suffix" on-click="_openCloseCalender"></paper-icon-button>
            </paper-input>

            <template is="dom-if" if="[[_pickerVisible]]">
                <paper-card id="dialog" class="paper-date-picker-dialog" on-iron-overlay-closed="dismissDialog"
                            elevation="5">
                    <paper-date-picker locale="[[locale]]" id="datePicker" date="{{_date}}" min-date="[[_minDate]]"
                                       max-date="[[_maxDate]]"></paper-date-picker>
                </paper-card>
            </template>

        </div>

    </template>

    <script>

        class ActindoDatePicker extends Polymer.Element {

            static get is() {
                return "actindo-date-picker";
            }

            static get properties() {
                return {

                    /**
                     * Use moment.js date format convention
                     */
                    format:
                        {
                            type: String,
                            value: "l",
                        },

                    /**
                     * Moment.js locale definition
                     */
                    locale:
                        {
                            type: String,
                            value: "de",
                        },

                    /**
                     * Resulting date
                     *
                     * @private
                     */
                    _date:
                        {
                            type: String,
                            observer: "_onDateChanged"
                        },

                    /**
                     * Value for paper input
                     */
                    value:
                        {
                            type: String,
                            notify: true,
                            observer: "_onValueChanged"
                        },

                    /**
                     * Is date picker visible
                     *
                     * @private
                     */
                    _pickerVisible:
                        {
                            type: Boolean,
                            value: false
                        },

                    /**
                     * Name for the date field
                     */
                    name:
                        {
                            type: String,
                        },

                    /**
                     * Label for the paper input
                     */
                    label:
                        {
                            type: String
                        },

                    /**
                     * Minimum date
                     */
                    minDate:
                        {
                            type: String,
                            observer: "_onMinDateChanged"
                        },

                    /**
                     * Maximum date
                     */
                    maxDate:
                        {
                            type: String,
                            observer: "_onMaxDateChanged"
                        },

                    /**
                     * Minimum date as date object
                     *
                     * @private
                     */
                    _minDate:
                        {
                            type: Date,
                            value: new Date(),
                        },

                    /**
                     * Minimum date as date object
                     *
                     * @private
                     */
                    _maxDate:
                        {
                            type: Date,
                            value: new Date(),
                        },

                    /**
                     *  Validation result
                     */
                    invalid:
                        {
                            type: Boolean,
                            value: false,
                            notify: true
                        },

                    /**
                     * Error message in case of invalid input
                     *
                     * @private
                     */
                    _errorMessage:
                        {
                            type: String,
                        },

                    /**
                     * Required property - passed on to underlying paper input
                     */
                    required:
                        {
                            type: Boolean,
                            value: false
                        },

                    /**
                     * Disabled property - passed on to underlying paper input
                     */
                    disabled:
                        {
                            type: Boolean,
                            value: false
                        }

                };
            }

            /**
             * Validate for form support
             */
            validate() {
                let me = this;
                let date = moment(me.value, me.format, me.locale, true);

                let invalid = !date.isValid();
                if (!invalid) {
                    if ((this._minDate && date.toDate() < this._minDate) || (this._maxDate && date.toDate() > this._maxDate)) {
                        this.set("_errorMessage", "Date out of range");
                        invalid = true;
                    }
                    else {
                        invalid = false;
                    }
                }
                else {
                    this.set("_errorMessage", "Date invalid");
                }
                this.set("invalid", invalid);

                return !this.invalid;
            }

            /**
             * Converts given min date to date object used by date picker
             *
             * @param {String} newValue
             * @param {String} oldValue
             *
             * @private
             */
            _onMinDateChanged(newValue, oldValue) {
                if (newValue !== oldValue) {
                    let me = this;
                    let date = moment(newValue, me.format, me.locale, true).toDate();
                    this.set("_minDate", date);
                }
            }

            /**
             * Converts given max date to date object used by date picker
             *
             * @param {String} newValue
             * @param {String} oldValue
             *
             * @private
             */
            _onMaxDateChanged(newValue, oldValue) {
                if (newValue !== oldValue) {
                    let me = this;
                    let date = moment(newValue, me.format, me.locale, true).toDate();
                    this.set("_maxDate", date);
                }
            }

            /**
             * Set value for calendar after waiting time and if valid
             *
             * @param {String} newValue
             * @param {String} oldValue
             *
             * @private
             */
            _onValueChanged(newValue, oldValue) {
                if (newValue !== oldValue) {
                    let me = this;
                    // If value different then set
                    me._debouncer = Polymer.Debouncer.debounce(me._debouncer,
                        Polymer.Async.timeOut.after(200),
                        () => {
                            me._convertToDate(newValue);
                        });
                }
            }

            /**
             * Convert selected date value to format used in input field
             *
             * @param {String} value
             *
             * @private
             */
            _convertToOutputFormat(value) {
                let me = this;
                let date = new Date(value);

                return moment(date).locale(me.locale).format(this.format);
            }

            /**
             * Convert input date to date in calendar if valid
             *
             * @param {String} value
             *
             * @private
             */
            _convertToDate(value) {
                let me = this;
                let date = moment(value, me.format, me.locale, true);

                if (date.isValid()) {
                    me.set("_date", new Date(date.format()))
                }

                this.validate();
            }

            /**
             * Convert selected date in calendar to output date
             *
             * @param {String} newValue
             * @param {String} oldValue
             *
             * @private
             */
            _onDateChanged(newValue, oldValue) {
                let me = this;
                let formatted = this._convertToOutputFormat(newValue);
                me.set("value", formatted);
            }

            /**
             * Handle UI - set correct input type for mobile devices
             */
            prepareUi() {
                let os = this._getOS();
                if (os === "iOS" || os === "Android") {
                    this.set("_dateInputType", "date");
                }
                else {
                    this.set("_dateInputType", "");
                }
            }

            /**
             * Get the operating system from userAgent/platform to set the correct UI properties
             *
             * @returns {String}
             *
             * @private
             */
            _getOS() {
                let userAgent = window.navigator.userAgent;
                let platform = window.navigator.platform;
                let macosPlatforms = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'];
                let windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE'];
                let iosPlatforms = ['iPhone', 'iPad', 'iPod'];
                let os = null;

                if (macosPlatforms.indexOf(platform) !== -1) {
                    os = 'Mac OS';
                }
                else if (iosPlatforms.indexOf(platform) !== -1) {
                    os = 'iOS';
                }
                else if (windowsPlatforms.indexOf(platform) !== -1) {
                    os = 'Windows';
                }
                else if (/Android/.test(userAgent)) {
                    os = 'Android';
                }
                else if (!os && /Linux/.test(platform)) {
                    os = 'Linux';
                }

                return os;
            }

            /**
             * Binds the click events during initial callback
             */
            connectedCallback() {
                super.connectedCallback();
                let me = this;

                this._downHandler = this._onDown.bind(this);
                this._upHandler = this._onUp.bind(this);

                this.prepareUi();
            }

            /**
             * Mouse "Up" event - Handle correct behavior to close calendar
             *
             * @param {Object} event
             *
             * @private
             */
            _onUp(event) {
                let found = false;

                for (let i = 0; i < event.path.length; i++) {
                    let row = event.path[i];
                    if (row.nodeName === "ACTINDO-DATE-PICKER") {
                        found = true;
                        break;
                    }
                }
                if (this._changeOpenState && !found) {
                    this._openCloseCalender();
                }
            }

            /**
             * Mouse "Down" event - Handle correct behavior to close calendar
             *
             * @param {Object} event
             *
             * @private
             */
            _onDown(event) {
                let found = false;
                for (let i = 0; i < event.path.length; i++) {
                    let row = event.path[i];
                    if (row.nodeName === "ACTINDO-DATE-PICKER") {
                        found = true;
                        break;
                    }
                }
                this._changeOpenState = !found;
            }

            /**
             * Adds or removes event listeners for mouse events - open / closes calender
             *
             * @private
             */
            _openCloseCalender() {
                this.set("_pickerVisible", !this._pickerVisible);
                let me = this;
                if (this._pickerVisible) {
                    document.addEventListener("mousedown", this._downHandler);
                    document.addEventListener("mouseup", this._upHandler);
                }
                else {
                    document.removeEventListener("mousedown", this._downHandler);
                    document.removeEventListener("mouseup", this._upHandler);
                }
            }
        }

        customElements.define(ActindoDatePicker.is, ActindoDatePicker);

    </script>

</dom-module>
